From 9b0aa73bc2876144e9c87555f6fe62a894a08deb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Martin=20M=C3=A1gr?= <mmagr@redhat.com>
Date: Tue, 3 Jan 2017 13:55:05 +0100
Subject: [PATCH] Remove network related tests

---
 spec/api/process_spec.rb        | 1675 ---------------------------------------
 spec/client/http_socket_spec.rb |   84 --
 spec/client/process_spec.rb     |  353 ---------
 spec/server/filter_spec.rb      |   91 ---
 spec/server/handle_spec.rb      |   74 --
 spec/server/mutate_spec.rb      |   45 --
 spec/server/process_spec.rb     |  837 -------------------
 7 files changed, 3159 deletions(-)
 delete mode 100644 spec/api/process_spec.rb
 delete mode 100644 spec/client/http_socket_spec.rb
 delete mode 100644 spec/client/process_spec.rb
 delete mode 100644 spec/server/handle_spec.rb
 delete mode 100644 spec/server/mutate_spec.rb
 delete mode 100644 spec/server/process_spec.rb

diff --git a/spec/api/process_spec.rb b/spec/api/process_spec.rb
deleted file mode 100644
index 484d937..0000000
--- a/spec/api/process_spec.rb
+++ /dev/null
@@ -1,1675 +0,0 @@
-require File.join(File.dirname(__FILE__), "..", "helpers.rb")
-
-require "sensu/api/process"
-require "sensu/server/process"
-
-describe "Sensu::API::Process" do
-  include Helpers
-
-  before do
-    async_wrapper do
-      client = client_template
-      client[:timestamp] = epoch
-      @event = event_template
-      @check = check_template
-      redis.flushdb do
-        redis.set("client:i-424242", Sensu::JSON.dump(client)) do
-          redis.sadd("clients", "i-424242") do
-            redis.hset("events:i-424242", "test", Sensu::JSON.dump(@event)) do
-              redis.set("result:i-424242:test", Sensu::JSON.dump(@check)) do
-                redis.set("stash:test/test", Sensu::JSON.dump({:key => "value"})) do
-                  redis.expire("stash:test/test", 3600) do
-                    redis.sadd("stashes", "test/test") do
-                      redis.sadd("result:i-424242", "test") do
-                        redis.rpush("history:i-424242:test", 0) do
-                          @redis = nil
-                          async_done
-                        end
-                      end
-                    end
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can handle integer parameters" do
-    handler = Sensu::API::HTTPHandler.new(nil)
-    expect(handler.integer_parameter("42")).to eq(42)
-    expect(handler.integer_parameter("abc")).to eq(nil)
-    expect(handler.integer_parameter("42\nabc")).to eq(nil)
-  end
-
-  it "can provide basic version and health information" do
-    api_test do
-      http_request(4567, "/info") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body[:sensu][:version]).to eq(Sensu::VERSION)
-        expect(body[:redis][:connected]).to be(true)
-        expect(body[:transport][:connected]).to be(true)
-        expect(body[:transport][:keepalives][:messages]).to be_kind_of(Integer)
-        expect(body[:transport][:keepalives][:consumers]).to be_kind_of(Integer)
-        expect(body[:transport][:results][:messages]).to be_kind_of(Integer)
-        expect(body[:transport][:results][:consumers]).to be_kind_of(Integer)
-        async_done
-      end
-    end
-  end
-
-  it "can provide connection and queue monitoring" do
-    api_test do
-      http_request(4567, "/health?consumers=0&messages=1000") do |http, body|
-        expect(http.response_header.status).to eq(204)
-        expect(http.response_header.http_reason).to eq('No Content')
-        expect(body).to be_empty
-        http_request(4567, "/health?consumers=1000") do |http, body|
-          expect(http.response_header.status).to eq(412)
-          expect(body).to be_empty
-          http_request(4567, "/health?consumers=1000&messages=1000") do |http, body|
-            expect(http.response_header.status).to eq(412)
-            async_done
-          end
-        end
-      end
-    end
-  end
-
-  it "can provide current events" do
-    api_test do
-      http_request(4567, "/events") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_kind_of(Array)
-        test_event = Proc.new do |event|
-          event[:check][:name] == "test"
-        end
-        expect(body).to contain(test_event)
-        async_done
-      end
-    end
-  end
-
-  it "can provide current events for a specific client" do
-    api_test do
-      http_request(4567, "/events/i-424242") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_kind_of(Array)
-        test_event = Proc.new do |event|
-          event[:check][:name] == "test"
-        end
-        expect(body).to contain(test_event)
-        async_done
-      end
-    end
-  end
-
-  it "can create a client" do
-    api_test do
-      options = {
-        :body => {
-          :name => "i-888888",
-          :address => "8.8.8.8",
-          :subscriptions => [
-            "test"
-          ]
-        }
-      }
-      http_request(4567, "/clients", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(201)
-        expect(body).to be_kind_of(Hash)
-        expect(body[:name]).to eq("i-888888")
-        async_done
-      end
-    end
-  end
-
-  it "can not create a client with an invalid post body (invalid name)" do
-    api_test do
-      options = {
-        :body => {
-          :name => "i-$$$$$$",
-          :address => "8.8.8.8",
-          :subscriptions => [
-            "test"
-          ]
-        }
-      }
-      http_request(4567, "/clients", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        async_done
-      end
-    end
-  end
-
-  it "can not create a client with an invalid post body (multiline name)" do
-    api_test do
-      options = {
-        :body => {
-          :name => "i-424242\ni-424242",
-          :address => "8.8.8.8",
-          :subscriptions => [
-            "test"
-          ]
-        }
-      }
-      http_request(4567, "/clients", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        async_done
-      end
-    end
-  end
-
-  it "can not create a client with an invalid post body (missing address)" do
-    api_test do
-      options = {
-        :body => {
-          :name => "i-424242",
-          :subscriptions => [
-            "test"
-          ]
-        }
-      }
-      http_request(4567, "/clients", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        async_done
-      end
-    end
-  end
-
-  it "can not create a client with an invalid post body (invalid subscriptions)" do
-    api_test do
-      options = {
-        :body => {
-          :name => "i-424242",
-          :address => "8.8.8.8",
-          :subscriptions => "invalid"
-        }
-      }
-      http_request(4567, "/clients", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        async_done
-      end
-    end
-  end
-
-  it "can provide current clients" do
-    api_test do
-      http_request(4567, "/clients") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_kind_of(Array)
-        test_client = Proc.new do |client|
-          client[:name] == "i-424242"
-        end
-        expect(body).to contain(test_client)
-        async_done
-      end
-    end
-  end
-
-  it "can provide defined checks" do
-    api_test do
-      http_request(4567, "/checks") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_kind_of(Array)
-        test_check = Proc.new do |check|
-          check[:name] == "tokens"
-        end
-        expect(body).to contain(test_check)
-        async_done
-      end
-    end
-  end
-
-  it "can provide defined checks without standalone checks" do
-    api_test do
-      http_request(4567, "/checks") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_kind_of(Array)
-        test_check = Proc.new do |check|
-          check[:name] == "standalone"
-        end
-        expect(body).to_not contain(test_check)
-        async_done
-      end
-    end
-  end
-
-  it "can provide a specific check" do
-    api_test do
-      http_request(4567, "/checks/merger") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_kind_of(Hash)
-        expect(body).to eq({:command=>"echo -n merger", :interval=>60, :subscribers=>["test"], :name=>"merger"})
-        async_done
-      end
-    end
-  end
-
-  it "cannot provide a specific standalone check" do
-    api_test do
-      http_request(4567, "/checks/standalone") do |http, body|
-        expect(http.response_header.status).to eq(404)
-        async_done
-      end
-    end
-  end
-
-  it "can provide a specific event" do
-    api_test do
-      http_request(4567, "/events/i-424242/test") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_kind_of(Hash)
-        expect(body[:client]).to be_kind_of(Hash)
-        expect(body[:check]).to be_kind_of(Hash)
-        expect(body[:client][:name]).to eq("i-424242")
-        expect(body[:check][:name]).to eq("test")
-        expect(body[:check][:output]).to eq("WARNING")
-        expect(body[:check][:status]).to eq(1)
-        expect(body[:check][:issued]).to be_within(10).of(epoch)
-        expect(body[:action]).to eq("create")
-        expect(body[:occurrences]).to eq(1)
-        async_done
-      end
-    end
-  end
-
-  it "can not provide a nonexistent event" do
-    api_test do
-      http_request(4567, "/events/i-424242/nonexistent") do |http, body|
-        expect(http.response_header.status).to eq(404)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can delete an event" do
-    api_test do
-      result_queue do |payload|
-        result = Sensu::JSON.load(payload)
-        expect(result[:client]).to eq("i-424242")
-        expect(result[:check][:name]).to eq("test")
-        expect(result[:check][:status]).to eq(0)
-        timer(0.5) do
-          async_done
-        end
-      end
-      timer(0.5) do
-        http_request(4567, "/events/i-424242/test", :delete) do |http, body|
-          expect(http.response_header.status).to eq(202)
-          expect(body).to include(:issued)
-          timer(1) do
-            redis.hget("events:i-424242", "test") do |event_json|
-              expect(event_json).to be_nil
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can delete an event when the client has a signature" do
-    @server = Sensu::Server::Process.new(options)
-    async_wrapper do
-      @server.setup_connections do
-        @server.setup_keepalives
-        @server.setup_results
-        keepalive = client_template
-        keepalive[:timestamp] = epoch
-        keepalive[:signature] = "foo"
-        setup_transport do |transport|
-          transport.publish(:direct, "keepalives", Sensu::JSON.dump(keepalive))
-        end
-        timer(1) do
-          redis.get("client:i-424242:signature") do |signature|
-            expect(signature).to eq("foo")
-            check_result = result_template
-            check_result[:signature] = "foo"
-            check_result[:check][:name] = 'signature_test'
-            @server.process_check_result(check_result)
-            timer(1) do
-              api_test do
-                http_request(4567, "/events/i-424242/signature_test", :delete) do |http, body|
-                  expect(http.response_header.status).to eq(202)
-                  expect(body).to include(:issued)
-                  timer(2) do
-                    redis.hget("events:i-424242", "signature_test") do |event_json|
-                      expect(event_json).to be_nil
-                      async_done
-                    end
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can not delete a nonexistent event" do
-    api_test do
-      http_request(4567, "/events/i-424242/nonexistent", :delete) do |http, body|
-        expect(http.response_header.status).to eq(404)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can resolve an event" do
-    api_test do
-      result_queue do |payload|
-        result = Sensu::JSON.load(payload)
-        expect(result[:client]).to eq("i-424242")
-        expect(result[:check][:name]).to eq("test")
-        expect(result[:check][:status]).to eq(0)
-        timer(0.5) do
-          async_done
-        end
-      end
-      timer(0.5) do
-        options = {
-          :body => {
-            :client => "i-424242",
-            :check => "test"
-          }
-        }
-        http_request(4567, "/resolve", :post, options) do |http, body|
-          expect(http.response_header.status).to eq(202)
-          expect(body).to include(:issued)
-        end
-      end
-    end
-  end
-
-  it "can not resolve a nonexistent event" do
-    api_test do
-      options = {
-        :body => {
-          :client => "i-424242",
-          :check => "nonexistent"
-        }
-      }
-      http_request(4567, "/resolve", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(404)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can not resolve an event with an invalid post body" do
-    api_test do
-      options = {
-        :body => "i-424242/test"
-      }
-      http_request(4567, "/resolve", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can not resolve an event when missing data" do
-    api_test do
-      options = {
-        :body => {
-          :client => "i-424242"
-        }
-      }
-      http_request(4567, "/resolve", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can provide a specific client" do
-    api_test do
-      http_request(4567, "/clients/i-424242") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_kind_of(Hash)
-        expect(body[:name]).to eq("i-424242")
-        expect(body[:address]).to eq("127.0.0.1")
-        expect(body[:subscriptions]).to eq(["test"])
-        expect(body[:timestamp]).to be_within(10).of(epoch)
-        async_done
-      end
-    end
-  end
-
-  it "can not provide a nonexistent client" do
-    api_test do
-      http_request(4567, "/clients/nonexistent") do |http, body|
-        expect(http.response_header.status).to eq(404)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can create and provide a client" do
-    api_test do
-      options = {
-        :body => {
-          :name => "i-888888",
-          :address => "8.8.8.8",
-          :subscriptions => [
-            "test"
-          ]
-        }
-      }
-      http_request(4567, "/clients", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(201)
-        expect(body).to be_kind_of(Hash)
-        expect(body[:name]).to eq("i-888888")
-        http_request(4567, "/clients/i-888888") do |http, body|
-          expect(http.response_header.status).to eq(200)
-          expect(body).to be_kind_of(Hash)
-          expect(body[:name]).to eq("i-888888")
-          expect(body[:address]).to eq("8.8.8.8")
-          expect(body[:subscriptions]).to eq(["test"])
-          expect(body[:keepalives]).to be(false)
-          expect(body[:timestamp]).to be_within(10).of(epoch)
-          async_done
-        end
-      end
-    end
-  end
-
-  it "can create a client expected to produce keepalives (eventually)" do
-    api_test do
-      options = {
-        :body => {
-          :name => "i-888888",
-          :address => "8.8.8.8",
-          :subscriptions => [
-            "test"
-          ],
-          :keepalives => true
-        }
-      }
-      http_request(4567, "/clients", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(201)
-        http_request(4567, "/clients/i-888888") do |http, body|
-          expect(http.response_header.status).to eq(200)
-          expect(body[:keepalives]).to be(true)
-          async_done
-        end
-      end
-    end
-  end
-
-  it "can request check history for a client" do
-    api_test do
-      http_request(4567, "/clients/i-424242/history") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_kind_of(Array)
-        expect(body.size).to eq(1)
-        expect(body[0][:check]).to eq("test")
-        expect(body[0][:history]).to be_kind_of(Array)
-        expect(body[0][:last_execution]).to eq(1363224805)
-        expect(body[0][:last_status]).to eq(0)
-        expect(body[0][:last_result]).to be_kind_of(Hash)
-        expect(body[0][:last_result][:output]).to eq("WARNING")
-        async_done
-      end
-    end
-  end
-
-  it "can delete a client" do
-    api_test do
-      http_request(4567, "/clients/i-424242", :delete) do |http, body|
-        expect(http.response_header.status).to eq(202)
-        expect(body).to include(:issued)
-        async_done
-      end
-    end
-  end
-
-  it "can not delete a noexistent client" do
-    api_test do
-      http_request(4567, "/clients/nonexistent", :delete) do |http, body|
-        expect(http.response_header.status).to eq(404)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can provide a specific defined check" do
-    api_test do
-      http_request(4567, "/checks/tokens") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_kind_of(Hash)
-        expect(body[:name]).to eq("tokens")
-        expect(body[:interval]).to eq(1)
-        async_done
-      end
-    end
-  end
-
-  it "can not provide a nonexistent defined check" do
-    api_test do
-      http_request(4567, "/checks/nonexistent") do |http, body|
-        expect(http.response_header.status).to eq(404)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can issue a check request" do
-    api_test do
-      options = {
-        :body => {
-          :check => "tokens",
-          :subscribers => [
-            "test",
-            "roundrobin:rspec",
-            1
-          ]
-        }
-      }
-      http_request(4567, "/request", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(202)
-        expect(body).to include(:issued)
-        async_done
-      end
-    end
-  end
-
-  it "can not issue a check request with an invalid post body" do
-    api_test do
-      options = {
-        :body => {
-          :check => "tokens",
-          :subscribers => "invalid"
-        }
-      }
-      http_request(4567, "/request", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can not issue a check request when missing data" do
-    api_test do
-      options = {
-        :body => {
-          :subscribers => [
-            "test"
-          ]
-        }
-      }
-      http_request(4567, "/request", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can not issue a check request for a nonexistent defined check" do
-    api_test do
-      options = {
-        :body => {
-          :check => "nonexistent",
-          :subscribers => [
-            "test"
-          ]
-        }
-      }
-      http_request(4567, "/request", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(404)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can create a stash (json document)" do
-    api_test do
-      options = {
-        :body => {
-          :path => "tester",
-          :content => {
-            :key => "value"
-          }
-        }
-      }
-      http_request(4567, "/stashes", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(201)
-        expect(body).to include(:path)
-        expect(body[:path]).to eq("tester")
-        redis.get("stash:tester") do |stash_json|
-          stash = Sensu::JSON.load(stash_json)
-          expect(stash).to eq({:key => "value"})
-          redis.ttl("stash:tester") do |ttl|
-            expect(ttl).to eq(-1)
-            async_done
-          end
-        end
-      end
-    end
-  end
-
-  it "can not create a stash when missing data" do
-    api_test do
-      options = {
-        :body => {
-          :path => "tester"
-        }
-      }
-      http_request(4567, "/stashes", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        expect(body).to be_empty
-        redis.exists("stash:tester") do |exists|
-          expect(exists).to be(false)
-          async_done
-        end
-      end
-    end
-  end
-
-  it "can not create a non-json stash" do
-    api_test do
-      options = {
-        :body => {
-          :path => "tester",
-          :content => "value"
-        }
-      }
-      http_request(4567, "/stashes", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        expect(body).to be_empty
-        redis.exists("stash:tester") do |exists|
-          expect(exists).to be(false)
-          async_done
-        end
-      end
-    end
-  end
-
-  it "can create a stash with id (path)" do
-    api_test do
-      options = {
-        :body => {
-          :key => "value"
-        }
-      }
-      http_request(4567, "/stash/tester", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(201)
-        expect(body).to include(:path)
-        redis.get("stash:tester") do |stash_json|
-          stash = Sensu::JSON.load(stash_json)
-          expect(stash).to eq({:key => "value"})
-          async_done
-        end
-      end
-    end
-  end
-
-  it "can create a stash with id (path) containing a uri encoded space" do
-    api_test do
-      options = {
-        :body => {
-          :key => "value"
-        }
-      }
-      http_request(4567, "/stash/foo%20bar", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(201)
-        expect(body).to include(:path)
-        redis.get("stash:foo bar") do |stash_json|
-          stash = Sensu::JSON.load(stash_json)
-          expect(stash).to eq({:key => "value"})
-          async_done
-        end
-      end
-    end
-  end
-
-  it "can not create a non-json stash with id" do
-    api_test do
-      options = {
-        :body => "should fail"
-      }
-      http_request(4567, "/stash/tester", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        expect(body).to be_empty
-        redis.exists("stash:tester") do |exists|
-          expect(exists).to be(false)
-          async_done
-        end
-      end
-    end
-  end
-
-  it "can provide a stash" do
-    api_test do
-      http_request(4567, "/stash/test/test") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_kind_of(Hash)
-        expect(body[:key]).to eq("value")
-        async_done
-      end
-    end
-  end
-
-  it "can indicate if a stash exists" do
-    api_test do
-      http_request(4567, "/stash/test/test", :head) do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can not provide a nonexistent stash" do
-    api_test do
-      http_request(4567, "/stash/nonexistent") do |http, body|
-        expect(http.response_header.status).to eq(404)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can provide multiple stashes" do
-    api_test do
-      http_request(4567, "/stashes") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_kind_of(Array)
-        expect(body[0]).to be_kind_of(Hash)
-        expect(body[0][:path]).to eq("test/test")
-        expect(body[0][:content]).to eq({:key => "value"})
-        expect(body[0][:expire]).to be_within(3).of(3600)
-        async_done
-      end
-    end
-  end
-
-  it "can delete a stash" do
-    api_test do
-      http_request(4567, "/stash/test/test", :delete) do |http, body|
-        expect(http.response_header.status).to eq(204)
-        expect(http.response_header.http_reason).to eq('No Content')
-        expect(body).to be_empty
-        redis.exists("stash:test/test") do |exists|
-          expect(exists).to be(false)
-          async_done
-        end
-      end
-    end
-  end
-
-  it "can not delete a nonexistent stash" do
-    api_test do
-      http_request(4567, "/stash/nonexistent", :delete) do |http, body|
-        expect(http.response_header.status).to eq(404)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can provide a list of aggregates" do
-    api_test do
-      server = Sensu::Server::Process.new(options)
-      server.setup_redis do
-        server.aggregate_check_result(client_template, check_template)
-        timer(1) do
-          http_request(4567, "/aggregates") do |http, body|
-            expect(body).to be_kind_of(Array)
-            expect(body).to include({:name => "test"})
-            async_done
-          end
-        end
-      end
-    end
-  end
-
-  it "can delete an aggregate" do
-    api_test do
-      server = Sensu::Server::Process.new(options)
-      server.setup_redis do
-        server.aggregate_check_result(client_template, check_template)
-        timer(1) do
-          http_request(4567, "/aggregates/test", :delete) do |http, body|
-            expect(http.response_header.status).to eq(204)
-            expect(http.response_header.http_reason).to eq('No Content')
-            expect(body).to be_empty
-            redis.sismember("aggregates", "test") do |exists|
-              expect(exists).to be(false)
-              async_done
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can delete an aggregate with an all caps name" do
-    api_test do
-      server = Sensu::Server::Process.new(options)
-      server.setup_redis do
-        check = check_template
-        check[:name] = "TEST"
-        server.aggregate_check_result(client_template, check)
-        timer(1) do
-          http_request(4567, "/aggregates/TEST", :delete) do |http, body|
-            expect(http.response_header.status).to eq(204)
-            expect(http.response_header.http_reason).to eq('No Content')
-            expect(body).to be_empty
-            redis.sismember("aggregates", "TEST") do |exists|
-              expect(exists).to be(false)
-              async_done
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can not delete a nonexistent aggregate" do
-    api_test do
-      http_request(4567, "/aggregates/nonexistent", :delete) do |http, body|
-        expect(http.response_header.status).to eq(404)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can provide an aggregate" do
-    api_test do
-      server = Sensu::Server::Process.new(options)
-      server.setup_redis do
-        server.aggregate_check_result(client_template, check_template)
-        timer(1) do
-          http_request(4567, "/aggregates/test") do |http, body|
-            expect(http.response_header.status).to eq(200)
-            expect(body).to be_kind_of(Hash)
-            expect(body[:clients]).to eq(1)
-            expect(body[:checks]).to eq(1)
-            expect(body[:results][:ok]).to eq(0)
-            expect(body[:results][:warning]).to eq(1)
-            expect(body[:results][:critical]).to eq(0)
-            expect(body[:results][:unknown]).to eq(0)
-            expect(body[:results][:total]).to eq(1)
-            expect(body[:results][:stale]).to eq(0)
-            async_done
-          end
-        end
-      end
-    end
-  end
-
-  it "can provide an aggregate with a result max age" do
-    api_test do
-      server = Sensu::Server::Process.new(options)
-      server.setup_redis do
-        check = check_template
-        check[:executed] = epoch - 128
-        server.aggregate_check_result(client_template, check)
-        timer(1) do
-          http_request(4567, "/aggregates/test?max_age=120") do |http, body|
-            expect(http.response_header.status).to eq(200)
-            expect(body).to be_kind_of(Hash)
-            expect(body[:clients]).to eq(1)
-            expect(body[:checks]).to eq(1)
-            expect(body[:results][:ok]).to eq(0)
-            expect(body[:results][:warning]).to eq(0)
-            expect(body[:results][:critical]).to eq(0)
-            expect(body[:results][:unknown]).to eq(0)
-            expect(body[:results][:total]).to eq(0)
-            expect(body[:results][:stale]).to eq(1)
-            async_done
-          end
-        end
-      end
-    end
-  end
-
-  it "can not provide a nonexistent aggregate" do
-    api_test do
-      http_request(4567, "/aggregates/nonexistent") do |http, body|
-        expect(http.response_header.status).to eq(404)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can provide aggregate client information" do
-    api_test do
-      server = Sensu::Server::Process.new(options)
-      server.setup_redis do
-        server.aggregate_check_result(client_template, check_template)
-        timer(1) do
-          http_request(4567, "/aggregates/test/clients") do |http, body|
-            expect(http.response_header.status).to eq(200)
-            expect(body).to be_kind_of(Array)
-            expect(body[0]).to be_kind_of(Hash)
-            expect(body[0][:name]).to eq("i-424242")
-            expect(body[0][:checks]).to eq(["test"])
-            async_done
-          end
-        end
-      end
-    end
-  end
-
-  it "can not provide aggregate client information for a nonexistent aggregate" do
-    api_test do
-      http_request(4567, "/aggregates/nonexistent/clients") do |http, body|
-        expect(http.response_header.status).to eq(404)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can provide aggregate check information" do
-    api_test do
-      server = Sensu::Server::Process.new(options)
-      server.setup_redis do
-        server.aggregate_check_result(client_template, check_template)
-        timer(1) do
-          http_request(4567, "/aggregates/test/checks") do |http, body|
-            expect(http.response_header.status).to eq(200)
-            expect(body).to be_kind_of(Array)
-            expect(body[0]).to be_kind_of(Hash)
-            expect(body[0][:name]).to eq("test")
-            expect(body[0][:clients]).to eq(["i-424242"])
-            async_done
-          end
-        end
-      end
-    end
-  end
-
-  it "can not provide aggregate check information for a nonexistent aggregate" do
-    api_test do
-      http_request(4567, "/aggregates/nonexistent/checks") do |http, body|
-        expect(http.response_header.status).to eq(404)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can provide a aggregate result summary for a severity" do
-    api_test do
-      server = Sensu::Server::Process.new(options)
-      server.setup_redis do
-        server.aggregate_check_result(client_template, check_template)
-        timer(1) do
-          http_request(4567, "/aggregates/test/results/warning") do |http, body|
-            expect(http.response_header.status).to eq(200)
-            expect(body).to be_kind_of(Array)
-            expect(body[0]).to be_kind_of(Hash)
-            expect(body[0][:check]).to eq("test")
-            expect(body[0][:summary]).to be_kind_of(Array)
-            expect(body[0][:summary][0]).to be_kind_of(Hash)
-            expect(body[0][:summary][0][:output]).to eq("WARNING")
-            expect(body[0][:summary][0][:total]).to eq(1)
-            expect(body[0][:summary][0][:clients]).to eq(["i-424242"])
-            async_done
-          end
-        end
-      end
-    end
-  end
-
-  it "can provide a aggregate result summary for a severity with a result max age" do
-    api_test do
-      server = Sensu::Server::Process.new(options)
-      server.setup_redis do
-        check = check_template
-        check[:executed] = epoch - 128
-        server.aggregate_check_result(client_template, check)
-        timer(1) do
-          http_request(4567, "/aggregates/test/results/warning?max_age=120") do |http, body|
-            expect(http.response_header.status).to eq(200)
-            expect(body).to be_kind_of(Array)
-            expect(body).to be_empty
-            async_done
-          end
-        end
-      end
-    end
-  end
-
-  it "can not provide a aggregate result summary for an invalid severity" do
-    api_test do
-      http_request(4567, "/aggregates/test/results/invalid") do |http, body|
-        expect(http.response_header.status).to eq(400)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can not provide a aggregate result summary for a nonexistent aggregate" do
-    api_test do
-      http_request(4567, "/aggregates/nonexistent/results/warning") do |http, body|
-        expect(http.response_header.status).to eq(404)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can accept options requests without authentication" do
-    api_test do
-      options = {
-        :head => {
-          :authorization => nil
-        }
-      }
-      http_request(4567, "/events", :options, options) do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can provide cors headers" do
-    api_test do
-      http_request(4567, "/events") do |http, body|
-        cors_headers = {
-          :origin => http.response_header["ACCESS_CONTROL_ALLOW_ORIGIN"],
-          :methods => http.response_header["ACCESS_CONTROL_ALLOW_METHODS"],
-          :credentials => http.response_header["ACCESS_CONTROL_ALLOW_CREDENTIALS"],
-          :headers => http.response_header["ACCESS_CONTROL_ALLOW_HEADERS"]
-        }
-        expected_headers = "Origin, X-Requested-With, Content-Type, Accept, Authorization"
-        expect(cors_headers[:origin]).to eq("*")
-        expect(cors_headers[:methods]).to eq("GET, POST, PUT, DELETE, OPTIONS")
-        expect(cors_headers[:credentials]).to eq("true")
-        expect(cors_headers[:headers]).to eq(expected_headers)
-        async_done
-      end
-    end
-  end
-
-  it "does not receive a response body when not authorized" do
-    api_test do
-      options = {
-        :head => {
-          :authorization => nil
-        }
-      }
-      http_request(4567, "/events", :put, options) do |http, body|
-        expect(http.response_header.status).to eq(401)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "does not create a stash when not authorized" do
-    api_test do
-      options = {
-        :head => {
-          :authorization => nil
-        },
-        :body => {
-          :path => "not_authorized",
-          :content => {
-            :key => "value"
-          }
-        }
-      }
-      http_request(4567, "/stashes", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(401)
-        expect(body).to be_empty
-        redis.exists("stash:not_authorized") do |exists|
-          expect(exists).to eq(false)
-          async_done
-        end
-      end
-    end
-  end
-
-  it "can publish a check result" do
-    api_test do
-      options = {
-        :body => {
-          :name => "rspec",
-          :output => "WARNING",
-          :status => 1
-        }
-      }
-      http_request(4567, "/results", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(202)
-        expect(body).to include(:issued)
-        async_done
-      end
-    end
-  end
-
-  it "can not publish a check result with an invalid post body" do
-    api_test do
-      options = {
-        :body => {
-          :name => "rspec",
-          :output => "WARNING",
-          :status => 1,
-          :source => "$invalid$"
-        }
-      }
-      http_request(4567, "/results", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can not publish a check result when missing data" do
-    api_test do
-      options = {
-        :body => {
-          :name => "missing_output"
-        }
-      }
-      http_request(4567, "/results", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can provide current results" do
-    api_test do
-      http_request(4567, "/results") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_kind_of(Array)
-        test_result = Proc.new do |result|
-          result_template(@check)
-        end
-        expect(body).to contain(test_result)
-        async_done
-      end
-    end
-  end
-
-  it "can provide current results for a specific client" do
-    api_test do
-      http_request(4567, "/results/i-424242") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_kind_of(Array)
-        test_result = Proc.new do |result|
-          result_template(@check)
-        end
-        expect(body).to contain(test_result)
-        async_done
-      end
-    end
-  end
-
-  it "can provide a specific result" do
-    api_test do
-      http_request(4567, "/results/i-424242/test") do |http, body|
-        expect(http.response_header.status).to eq(200)
-        expect(body).to be_kind_of(Hash)
-        expect(body).to eq(result_template(@check))
-        async_done
-      end
-    end
-  end
-
-  it "can delete a result" do
-    api_test do
-      http_request(4567, "/results/i-424242/test", :delete) do |http, body|
-        expect(http.response_header.status).to eq(204)
-        expect(http.response_header.http_reason).to eq('No Content')
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can not delete a nonexistent result" do
-    api_test do
-      http_request(4567, "/results/i-424242/nonexistent", :delete) do |http, body|
-        expect(http.response_header.status).to eq(404)
-        expect(body).to be_empty
-        async_done
-      end
-    end
-  end
-
-  it "can create a silenced registry entry for a subscription" do
-    api_test do
-      options = {
-        :body => {
-          :subscription => "test"
-        }
-      }
-      http_request(4567, "/silenced", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(201)
-        redis.get("silence:test:*") do |silenced_info_json|
-          silenced_info = Sensu::JSON.load(silenced_info_json)
-          expect(silenced_info[:id]).to eq("test:*")
-          expect(silenced_info[:subscription]).to eq("test")
-          expect(silenced_info[:check]).to be_nil
-          expect(silenced_info[:reason]).to be_nil
-          expect(silenced_info[:creator]).to be_nil
-          expect(silenced_info[:expire_on_resolve]).to eq(false)
-          async_done
-        end
-      end
-    end
-  end
-
-  it "can create a silenced registry entry for a check" do
-    api_test do
-      options = {
-        :body => {
-          :check => "test"
-        }
-      }
-      http_request(4567, "/silenced", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(201)
-        redis.get("silence:*:test") do |silenced_info_json|
-          silenced_info = Sensu::JSON.load(silenced_info_json)
-          expect(silenced_info[:id]).to eq("*:test")
-          expect(silenced_info[:subscription]).to be_nil
-          expect(silenced_info[:check]).to eq("test")
-          expect(silenced_info[:reason]).to be_nil
-          expect(silenced_info[:creator]).to be_nil
-          expect(silenced_info[:expire_on_resolve]).to eq(false)
-          async_done
-        end
-      end
-    end
-  end
-
-  it "can create a silenced registry entry that expires" do
-    api_test do
-      options = {
-        :body => {
-          :subscription => "test",
-          :check => "test",
-          :expire => 3600,
-          :reason => "testing",
-          :creator => "rspec",
-          :expire_on_resolve => true
-        }
-      }
-      http_request(4567, "/silenced", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(201)
-        redis.get("silence:test:test") do |silenced_info_json|
-          silenced_info = Sensu::JSON.load(silenced_info_json)
-          expect(silenced_info[:id]).to eq("test:test")
-          expect(silenced_info[:subscription]).to eq("test")
-          expect(silenced_info[:check]).to eq("test")
-          expect(silenced_info[:reason]).to eq("testing")
-          expect(silenced_info[:creator]).to eq("rspec")
-          expect(silenced_info[:expire_on_resolve]).to eq(true)
-          redis.ttl("silence:test:test") do |ttl|
-            expect(ttl).to be_within(10).of(3600)
-            async_done
-          end
-        end
-      end
-    end
-  end
-
-  [
-    "client:my-test-client",
-    "roundrobin:load_balancer",
-    "roundrobin:foo_bar-baz",
-    "load-balancer",
-    "load_balancer",
-    "loadbalancer"
-  ].each do |subscription|
-    it "can create and retrieve silenced registry entry with a subscription e.g. #{subscription}" do
-      api_test do
-        options = {
-          :body => {
-            :subscription => subscription,
-            :check => "test"
-          }
-        }
-        http_request(4567, "/silenced", :post, options) do |http, body|
-          expect(http.response_header.status).to eq(201)
-          redis.get("silence:#{subscription}:test") do |silenced_info_json|
-            timer(1) do
-              http_request(4567, "/silenced/subscriptions/#{subscription}") do |http, body|
-                expect(http.response_header.status).to eq(200)
-                expect(body).to be_kind_of(Array)
-                silence = body.last
-                expect(silence[:id]).to eq("#{subscription}:test")
-                async_done
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can not create a silenced registry entry when missing a subscription and/or check" do
-    api_test do
-      options = {
-        :body => {
-          :expire => 3600,
-          :reason => "testing",
-          :creator => "rspec",
-          :expire_on_resolve => true
-        }
-      }
-      http_request(4567, "/silenced", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        async_done
-      end
-    end
-  end
-
-  it "can not create a silenced registry entry with an invalid subscription" do
-    api_test do
-      options = {
-        :body => {
-          :subscription => 1,
-          :check => "test"
-        }
-      }
-      http_request(4567, "/silenced", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        async_done
-      end
-    end
-  end
-
-  it "can not create a silenced registry entry with an invalid check" do
-    api_test do
-      options = {
-        :body => {
-          :subscription => "test",
-          :check => 1
-        }
-      }
-      http_request(4567, "/silenced", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        async_done
-      end
-    end
-  end
-
-  it "can not create a silenced registry entry with an invalid expire" do
-    api_test do
-      options = {
-        :body => {
-          :subscription => "test",
-          :check => "test",
-          :expire => "3600"
-        }
-      }
-      http_request(4567, "/silenced", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        async_done
-      end
-    end
-  end
-
-  it "can not create a silenced registry entry with an invalid reason" do
-    api_test do
-      options = {
-        :body => {
-          :subscription => "test",
-          :check => "test",
-          :reason => 1
-        }
-      }
-      http_request(4567, "/silenced", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        async_done
-      end
-    end
-  end
-
-  it "can not create a silenced registry entry with an invalid creator" do
-    api_test do
-      options = {
-        :body => {
-          :subscription => "test",
-          :check => "test",
-          :creator => 1
-        }
-      }
-      http_request(4567, "/silenced", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        async_done
-      end
-    end
-  end
-
-  it "can not create a silenced registry entry with an invalid expire_on_resolve" do
-    api_test do
-      options = {
-        :body => {
-          :subscription => "test",
-          :check => "test",
-          :expire_on_resolve => "true"
-        }
-      }
-      http_request(4567, "/silenced", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(400)
-        async_done
-      end
-    end
-  end
-
-  it "can provide the silenced registry" do
-    api_test do
-      options = {
-        :body => {
-          :subscription => "test",
-          :check => "test",
-          :expire => 3600
-        }
-      }
-      http_request(4567, "/silenced", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(201)
-        http_request(4567, "/silenced") do |http, body|
-          expect(http.response_header.status).to eq(200)
-          expect(body).to be_kind_of(Array)
-          expect(body.length).to eq(1)
-          silenced_info = body.first
-          expect(silenced_info).to be_kind_of(Hash)
-          expect(silenced_info[:id]).to eq("test:test")
-          expect(silenced_info[:subscription]).to eq("test")
-          expect(silenced_info[:check]).to eq("test")
-          expect(silenced_info[:expire]).to be_within(10).of(3600)
-          http_request(4567, "/silenced/subscriptions/test") do |http, body|
-            expect(http.response_header.status).to eq(200)
-            expect(body).to be_kind_of(Array)
-            expect(body.length).to eq(1)
-            silenced_info = body.first
-            expect(silenced_info).to be_kind_of(Hash)
-            expect(silenced_info[:subscription]).to eq("test")
-            expect(silenced_info[:expire]).to be_within(10).of(3600)
-            http_request(4567, "/silenced/subscriptions/nonexistent") do |http, body|
-              expect(http.response_header.status).to eq(200)
-              expect(body).to be_kind_of(Array)
-              expect(body).to be_empty
-              http_request(4567, "/silenced/checks/test") do |http, body|
-                expect(http.response_header.status).to eq(200)
-                expect(body).to be_kind_of(Array)
-                expect(body.length).to eq(1)
-                silenced_info = body.first
-                expect(silenced_info).to be_kind_of(Hash)
-                expect(silenced_info[:check]).to eq("test")
-                expect(silenced_info[:expire]).to be_within(10).of(3600)
-                http_request(4567, "/silenced/checks/nonexistent") do |http, body|
-                  expect(http.response_header.status).to eq(200)
-                  expect(body).to be_kind_of(Array)
-                  expect(body).to be_empty
-                  async_done
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  context "when retrieving a silenced registry entry by it's id" do
-    it "can retrieve entry for silencing a specific check on all clients" do
-      api_test do
-        options = { :body => { :check => "test" } }
-        http_request(4567, "/silenced", :post, options) do |http, body|
-          http_request(4567, "/silenced/ids/*:test") do |http, body|
-            expect(http.response_header.status).to eq(200)
-            expect(body).to be_kind_of(Hash)
-            expect(body[:id]).to eq("*:test")
-            async_done
-          end
-        end
-      end
-    end
-
-    it "can retrieve entry for silencing all checks on a specific subscription" do
-      api_test do
-        options = { :body => { :subscription => "test" } }
-        http_request(4567, "/silenced", :post, options) do |http, body|
-          http_request(4567, "/silenced/ids/test:*") do |http, body|
-            expect(http.response_header.status).to eq(200)
-            expect(body).to be_kind_of(Hash)
-            expect(body[:id]).to eq("test:*")
-            async_done
-          end
-        end
-      end
-    end
-
-    it "cannot create an entry for silencing all checks on all subscriptions" do
-      api_test do
-        options = { :body => { :subscription => '*' } }
-        http_request(4567, "/silenced", :post, options) do |http, body|
-          expect(http.response_header.status).to eq(400)
-          async_done
-        end
-      end
-    end
-
-    it "handles requests for nonexistant ids" do
-      api_test do
-        http_request(4567, "/silenced/ids/nonexistant:nonexistant") do |http, body|
-          expect(http.response_header.status).to eq(404)
-          expect(body).to be_empty
-          async_done
-        end
-      end
-    end
-
-    it "handles requests for invalid ids" do
-      api_test do
-        http_request(4567, "/silenced/ids/invalid") do |http, body|
-          expect(http.response_header.status).to eq(404)
-          expect(body).to be_empty
-          http_request(4567, "/silenced/ids/:invalid") do |http, body|
-            expect(http.response_header.status).to eq(404)
-            expect(body).to be_empty
-            http_request(4567, "/silenced/ids/inv@(!alid") do |http, body|
-              expect(http.response_header.status).to eq(404)
-              expect(body).to be_empty
-              async_done
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can clear a silenced registry entry with a subscription and check" do
-    api_test do
-      options = {
-        :body => {
-          :subscription => "test",
-          :check => "test"
-        }
-      }
-      http_request(4567, "/silenced", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(201)
-        http_request(4567, "/silenced") do |http, body|
-          expect(http.response_header.status).to eq(200)
-          expect(body).to be_kind_of(Array)
-          expect(body.length).to eq(1)
-          silenced_info = body.first
-          expect(silenced_info).to be_kind_of(Hash)
-          expect(silenced_info[:subscription]).to eq("test")
-          expect(silenced_info[:check]).to eq("test")
-          http_request(4567, "/silenced/clear", :post, options) do |http, body|
-            expect(http.response_header.status).to eq(204)
-            http_request(4567, "/silenced/clear", :post, options) do |http, body|
-              expect(http.response_header.status).to eq(404)
-              http_request(4567, "/silenced") do |http, body|
-                expect(http.response_header.status).to eq(200)
-                expect(body).to be_kind_of(Array)
-                expect(body).to be_empty
-                async_done
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can clear a silenced registry entry with an id" do
-    api_test do
-      options = {
-        :body => {
-          :check => "test"
-        }
-      }
-      http_request(4567, "/silenced", :post, options) do |http, body|
-        expect(http.response_header.status).to eq(201)
-        http_request(4567, "/silenced") do |http, body|
-          expect(http.response_header.status).to eq(200)
-          expect(body).to be_kind_of(Array)
-          expect(body.length).to eq(1)
-          silenced_info = body.first
-          expect(silenced_info).to be_kind_of(Hash)
-          expect(silenced_info[:id]).to eq("*:test")
-          expect(silenced_info[:subscription]).to be_nil
-          expect(silenced_info[:check]).to eq("test")
-          options = {
-            :body => {
-              :id => "*:test"
-            }
-          }
-          http_request(4567, "/silenced/clear", :post, options) do |http, body|
-            expect(http.response_header.status).to eq(204)
-            http_request(4567, "/silenced/clear", :post, options) do |http, body|
-              expect(http.response_header.status).to eq(404)
-              http_request(4567, "/silenced") do |http, body|
-                expect(http.response_header.status).to eq(200)
-                expect(body).to be_kind_of(Array)
-                expect(body).to be_empty
-                async_done
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-end
diff --git a/spec/client/http_socket_spec.rb b/spec/client/http_socket_spec.rb
deleted file mode 100644
index 4631efb..0000000
--- a/spec/client/http_socket_spec.rb
+++ /dev/null
@@ -1,84 +0,0 @@
-require File.join(File.dirname(__FILE__), "..", "helpers.rb")
-
-require "sensu/client/process"
-
-describe "Sensu::Client::HTTPSocket" do
-  include Helpers
-
-  before do
-    @client = Sensu::Client::Process.new(options)
-  end
-
-  it "can provide basic version and transport information" do
-    async_wrapper do
-      @client.setup_transport do
-        @client.setup_http_socket
-        timer(1) do
-          http_request(3031, "/info") do |http, body|
-            expect(http.response_header.status).to eq(200)
-            expect(body[:sensu][:version]).to eq(Sensu::VERSION)
-            expect(body[:transport][:connected]).to be(true)
-            expect(body[:transport][:keepalives][:messages]).to be_kind_of(Integer)
-            expect(body[:transport][:keepalives][:consumers]).to be_kind_of(Integer)
-            expect(body[:transport][:results][:messages]).to be_kind_of(Integer)
-            expect(body[:transport][:results][:consumers]).to be_kind_of(Integer)
-            async_done
-          end
-        end
-      end
-    end
-  end
-
-  it "can accept external check result input" do
-    async_wrapper do
-      @client.setup_transport do
-        @client.setup_http_socket
-        result_queue do |payload|
-          result = Sensu::JSON.load(payload)
-          expect(result[:client]).to eq("i-424242")
-          expect(result[:check][:name]).to eq("http")
-          async_done
-        end
-        timer(1) do
-          options = {:body => {:name => "http", :output => "http", :status => 1}}
-          http_request(3031, "/results", :post, options)do |http, body|
-            expect(http.response_header.status).to eq(202)
-            expect(body).to eq({:response => "ok"})
-          end
-        end
-      end
-    end
-  end
-
-  it "can provide settings" do
-    async_wrapper do
-      @client.setup_transport do
-        @client.setup_http_socket
-        timer(1) do
-          options = {
-            :head => {
-              :authorization => [
-                "wrong",
-                "credentials"
-              ]
-            }
-          }
-          http_request(3031, "/settings", :get, options) do |http, body|
-            expect(http.response_header.status).to eq(401)
-            http_request(3031, "/settings", :get) do |http, body|
-              expect(http.response_header.status).to eq(200)
-              expect(body).to be_kind_of(Hash)
-              expect(body[:api][:password]).to eq("REDACTED")
-              http_request(3031, "/settings?redacted=false", :get) do |http, body|
-                expect(http.response_header.status).to eq(200)
-                expect(body).to be_kind_of(Hash)
-                expect(body[:api][:password]).to eq("bar")
-                async_done
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-end
diff --git a/spec/client/process_spec.rb b/spec/client/process_spec.rb
deleted file mode 100644
index fc165cb..0000000
--- a/spec/client/process_spec.rb
+++ /dev/null
@@ -1,353 +0,0 @@
-require File.join(File.dirname(__FILE__), "..", "helpers.rb")
-
-require "sensu/client/process"
-
-describe "Sensu::Client::Process" do
-  include Helpers
-
-  before do
-    @client = Sensu::Client::Process.new(options)
-  end
-
-  it "can connect to the transport" do
-    async_wrapper do
-      @client.setup_transport do |transport|
-        expect(transport.connected?).to eq(true)
-        async_done
-      end
-    end
-  end
-
-  it "can send a keepalive" do
-    async_wrapper do
-      keepalive_queue do |payload|
-        keepalive = Sensu::JSON.load(payload)
-        expect(keepalive[:name]).to eq("i-424242")
-        expect(keepalive[:service][:password]).to eq("REDACTED")
-        expect(keepalive[:version]).to eq(Sensu::VERSION)
-        expect(keepalive[:timestamp]).to be_within(10).of(epoch)
-        async_done
-      end
-      timer(0.5) do
-        @client.setup_transport do
-          @client.publish_keepalive
-        end
-      end
-    end
-  end
-
-  it "can schedule keepalive publishing" do
-    async_wrapper do
-      keepalive_queue do |payload|
-        keepalive = Sensu::JSON.load(payload)
-        expect(keepalive[:name]).to eq("i-424242")
-        async_done
-      end
-      timer(0.5) do
-        @client.setup_transport do
-          @client.publish_keepalive
-        end
-      end
-    end
-  end
-
-  it "can send a check result" do
-    async_wrapper do
-      result_queue do |payload|
-        result = Sensu::JSON.load(payload)
-        expect(result[:client]).to eq("i-424242")
-        expect(result[:check][:name]).to eq("test")
-        async_done
-      end
-      timer(0.5) do
-        @client.setup_transport do
-          check = result_template[:check]
-          @client.publish_check_result(check)
-        end
-      end
-    end
-  end
-
-  it "can send a deregistraion check result" do
-    async_wrapper do
-      result_queue do |payload|
-        result = Sensu::JSON.load(payload)
-        expect(result[:client]).to eq("i-424242")
-        expect(result[:check][:name]).to eq("deregistration")
-        expect(result[:check][:status]).to eq(1)
-        expect(result[:check][:handler]).to eq("DEREGISTER_HANDLER")
-        async_done
-      end
-      timer(0.5) do
-        @client.setup_transport do
-          @client.deregister
-        end
-      end
-    end
-  end
-
-  it "can execute a check command" do
-    async_wrapper do
-      result_queue do |payload|
-        result = Sensu::JSON.load(payload)
-        expect(result[:client]).to eq("i-424242")
-        expect(result[:check][:output]).to eq("WARNING\n")
-        expect(result[:check]).to have_key(:executed)
-        async_done
-      end
-      timer(0.5) do
-        @client.setup_transport do
-          @client.execute_check_command(check_template)
-        end
-      end
-    end
-  end
-
-  it "can substitute tokens in a check definition" do
-    check = check_template
-    check[:command] = "echo :::nested.attribute:::"
-    check[:foo] = [":::missing|foo:::"]
-    check[:bar] = {
-      :baz => ":::missing:::",
-      :qux => ":::missing|qux:::",
-      :quux => {
-        :corge => ":::missing:::",
-        :grault => ":::nonexistent:::",
-        :garply => ":::missing|garply:::",
-        :waldo => ":::name:::"
-      }
-    }
-    substituted, unmatched_tokens = @client.object_substitute_tokens(check)
-    expect(substituted[:name]).to eq("test")
-    expect(substituted[:command]).to eq("echo true")
-    expect(substituted[:foo].first).to eq("foo")
-    expect(substituted[:bar][:baz]).to eq("")
-    expect(substituted[:bar][:qux]).to eq("qux")
-    expect(substituted[:bar][:quux][:corge]).to eq("")
-    expect(substituted[:bar][:quux][:grault]).to eq("")
-    expect(substituted[:bar][:quux][:garply]).to eq("garply")
-    expect(substituted[:bar][:quux][:waldo]).to eq("i-424242")
-    expect(unmatched_tokens).to match_array(["missing", "nonexistent"])
-  end
-
-  it "can substitute tokens in a command with client attribute values, default values, and execute it" do
-    async_wrapper do
-      check = check_template
-      command = "echo :::nested.attribute|default::: :::missing|default:::"
-      command << " :::missing|::: :::nested.attribute:::::::nested.attribute:::"
-      command << " :::empty|localhost::: :::empty.hash|localhost:8080:::"
-      check[:command] = command
-      result_queue do |payload|
-        result = Sensu::JSON.load(payload)
-        expect(result[:client]).to eq("i-424242")
-        expect(result[:check][:command]).to eq(check[:command])
-        expect(result[:check][:output]).to eq("true default true:true localhost localhost:8080\n")
-        async_done
-      end
-      timer(0.5) do
-        @client.setup_transport do
-          @client.execute_check_command(check)
-        end
-      end
-    end
-  end
-
-  it "can substitute tokens in a command and handle unmatched tokens" do
-    async_wrapper do
-      result_queue do |payload|
-        result = Sensu::JSON.load(payload)
-        expect(result[:client]).to eq("i-424242")
-        expect(result[:check][:output]).to eq("Unmatched client token(s): nonexistent, noexistent.hash, empty.hash")
-        async_done
-      end
-      timer(0.5) do
-        @client.setup_transport do
-          check = check_template
-          check[:command] = "echo :::nonexistent::: :::noexistent.hash::: :::empty.hash:::"
-          @client.execute_check_command(check)
-        end
-      end
-    end
-  end
-
-  it "can run a check extension" do
-    async_wrapper do
-      result_queue do |payload|
-        result = Sensu::JSON.load(payload)
-        expect(result[:client]).to eq("i-424242")
-        expect(result[:check][:output]).to start_with("{")
-        expect(result[:check]).to have_key(:executed)
-        async_done
-      end
-      timer(0.5) do
-        @client.setup_transport do
-          check = {:name => "sensu_gc_metrics"}
-          @client.run_check_extension(check)
-        end
-      end
-    end
-  end
-
-  it "can receive a check request and execute the check" do
-    async_wrapper do
-      result_queue do |payload|
-        result = Sensu::JSON.load(payload)
-        expect(result[:client]).to eq("i-424242")
-        expect(result[:check][:output]).to eq("WARNING\n")
-        expect(result[:check][:status]).to eq(1)
-        async_done
-      end
-      timer(0.5) do
-        @client.setup_transport do
-          @client.setup_subscriptions
-          timer(1) do
-            setup_transport do |transport|
-              transport.publish(:fanout, "test", Sensu::JSON.dump(check_template))
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can receive a check request on a round-robin subscription" do
-    async_wrapper do
-      result_queue do |payload|
-        result = Sensu::JSON.load(payload)
-        expect(result[:client]).to eq("i-424242")
-        expect(result[:check][:output]).to eq("WARNING\n")
-        expect(result[:check][:status]).to eq(1)
-        async_done
-      end
-      timer(0.5) do
-        @client.setup_transport do
-          @client.setup_subscriptions
-          timer(1) do
-            setup_transport do |transport|
-              transport.publish(:direct, "roundrobin:test", Sensu::JSON.dump(check_template))
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can receive a check request and not execute the check due to safe mode" do
-    async_wrapper do
-      result_queue do |payload|
-        result = Sensu::JSON.load(payload)
-        expect(result[:client]).to eq("i-424242")
-        expect(result[:check][:output]).to include("safe mode")
-        expect(result[:check][:status]).to eq(3)
-        async_done
-      end
-      timer(0.5) do
-        @client.safe_mode = true
-        @client.setup_transport do
-          @client.setup_subscriptions
-          timer(1) do
-            setup_transport do |transport|
-              transport.publish(:fanout, "test", Sensu::JSON.dump(check_template))
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can schedule standalone check execution" do
-    async_wrapper do
-      expected = ["standalone", "sensu_gc_metrics"]
-      result_queue do |payload|
-        result = Sensu::JSON.load(payload)
-        expect(result[:client]).to eq("i-424242")
-        expect(result[:check]).to have_key(:issued)
-        expect(result[:check]).to have_key(:output)
-        expect(result[:check]).to have_key(:status)
-        expect(expected.delete(result[:check][:name])).not_to be_nil
-        if expected.empty?
-          async_done
-        end
-      end
-      timer(0.5) do
-        @client.setup_transport do
-          @client.setup_standalone
-        end
-      end
-    end
-  end
-
-  it "can subdue standalone check execution" do
-    async_wrapper do
-      result_queue do |payload|
-        result = Sensu::JSON.load(payload)
-        expect(result[:check][:name]).to eq("test")
-        async_done
-      end
-      timer(0.5) do
-        @client.setup_transport do
-          check = check_template
-          checks = [
-            check.merge(
-              :name => "subdued",
-              :subdue => {
-                :days => {
-                  :all => [
-                    {
-                      :begin => (Time.now - 3600).strftime("%l:00 %p").strip,
-                      :end => (Time.now + 3600).strftime("%l:00 %p").strip
-                    }
-                  ]
-                }
-              }
-            ),
-            check
-          ]
-          @client.schedule_checks(checks)
-        end
-      end
-    end
-  end
-
-  it "can calculate a check execution splay interval" do
-    allow(Time).to receive(:now).and_return("1414213569.032")
-    check = check_template
-    check[:interval] = 60
-    expect(@client.calculate_execution_splay(check)).to eq(3.321)
-    check[:interval] = 3600
-    expect(@client.calculate_execution_splay(check)).to eq(783.321)
-  end
-
-  it "can accept external result input via sockets" do
-    async_wrapper do
-      @client.setup_transport do
-        @client.setup_sockets
-        expected = ["tcp", "udp", "http"]
-        result_queue do |payload|
-          result = Sensu::JSON.load(payload)
-          expect(result[:client]).to eq("i-424242")
-          expect(expected.delete(result[:check][:name])).not_to be_nil
-          if expected.empty?
-            async_done
-          end
-        end
-        timer(1) do
-          EM::connect("127.0.0.1", 3030, nil) do |socket|
-            socket.send_data('{"name": "tcp", "output": "tcp", "status": 1}')
-            socket.close_connection_after_writing
-          end
-          EM::open_datagram_socket("127.0.0.1", 0, nil) do |socket|
-            data = '{"name": "udp", "output": "udp", "status": 1}'
-            socket.send_datagram(data, "127.0.0.1", 3030)
-            socket.close_connection_after_writing
-          end
-          options = {:body => {:name => "http", :output => "http", :status => 1}}
-          http_request(3031, "/results", :post, options)do |http, body|
-            expect(http.response_header.status).to eq(202)
-            expect(body).to eq({:response => "ok"})
-          end
-        end
-      end
-    end
-  end
-end
diff --git a/spec/server/filter_spec.rb b/spec/server/filter_spec.rb
index 78e222c..75d3695 100644
--- a/spec/server/filter_spec.rb
+++ b/spec/server/filter_spec.rb
@@ -85,97 +85,6 @@ describe "Sensu::Server::Filter" do
     expect(@server.filter_attributes_match?(@event, attributes)).to be(true)
   end
 
-  it "can filter an event using a filter" do
-    async_wrapper do
-      @event[:client][:environment] = "production"
-      @server.event_filter("production", @event) do |filtered, filter_name|
-        expect(filtered).to be(false)
-        expect(filter_name).to eq("production")
-        @server.event_filter("development", @event) do |filtered, filter_name|
-          expect(filtered).to be(true)
-          expect(filter_name).to eq("development")
-          @server.event_filter("nonexistent", @event) do |filtered|
-            expect(filtered).to be(false)
-            handler = {
-              :filter => "development"
-            }
-            @server.event_filtered?(handler, @event) do |filtered|
-              expect(filtered).to be(true)
-              handler = {
-                :filters => ["production"]
-              }
-              @server.event_filtered?(handler, @event) do |filtered|
-                expect(filtered).to be(false)
-                handler[:filters] = ["production", "development"]
-                @server.event_filtered?(handler, @event) do |filtered|
-                  expect(filtered).to be(true)
-                  async_done
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can filter events for a specific time window" do
-    async_wrapper do
-      @server.event_filter("time", @event) do |filtered|
-        expect(filtered).to be(true)
-        @server.settings[:filters][:time] = {
-          :when => {
-            :days => {
-              :all => [
-                {
-                  :begin => (Time.now + 3600).strftime("%l:00 %p").strip,
-                  :end => (Time.now + 5400).strftime("%l:00 %p").strip
-                }
-              ]
-            }
-          }
-        }
-        @server.event_filter("time", @event) do |filtered|
-          expect(filtered).to be(false)
-          async_done
-        end
-      end
-    end
-  end
-
-  it "can filter events" do
-    async_wrapper do
-      handler = {
-        :handle_flapping => false
-      }
-      @event[:action] = :flapping
-      @server.filter_event(handler, @event) do
-        raise "not filtered"
-      end
-      handler.delete(:handle_flapping)
-      @event[:action] = :create
-      @event[:check][:handle] = false
-      @server.filter_event(handler, @event) do
-        raise "not filtered"
-      end
-      @event[:check].delete(:handle)
-      handler[:severities] = ["critical"]
-      @server.filter_event(handler, @event) do
-        raise "not filtered"
-      end
-      handler.delete(:severities)
-      @event[:silenced] = true
-      @server.filter_event(handler, @event) do
-        raise "not filtered"
-      end
-      @event[:silenced] = false
-      @server.filter_event(handler, @event) do |event|
-        expect(event).to be(@event)
-        async_done
-      end
-    end
-  end
-
   it "can catch SyntaxErrors in eval filters" do
     attributes = {
       :occurrences => "eval: raise SyntaxError"
diff --git a/spec/server/handle_spec.rb b/spec/server/handle_spec.rb
deleted file mode 100644
index 17f1183..0000000
--- a/spec/server/handle_spec.rb
+++ /dev/null
@@ -1,74 +0,0 @@
-require File.join(File.dirname(__FILE__), "..", "helpers.rb")
-
-require "sensu/server/process"
-
-describe "Sensu::Server::Handle" do
-  include Helpers
-
-  before do
-    @server = Sensu::Server::Process.new(options)
-    settings = Sensu::Settings.get(options)
-    @handlers = settings[:handlers]
-    @event_data = Sensu::JSON.dump(event_template)
-    @extensions = Sensu::Extensions.get(options)
-  end
-
-  it "can handle an event handler error" do
-    on_error = @server.handler_error(@handlers[:file], @event_data)
-    expect(on_error.arity).to be(1)
-  end
-
-  it "can handle an event with a pipe handler" do
-    async_wrapper do
-      @server.handle_event(@handlers[:file], @event_data)
-      timer(1) do
-        async_done
-      end
-    end
-    expect(File.exists?("/tmp/sensu_event")).to be(true)
-    File.delete("/tmp/sensu_event")
-  end
-
-  it "can handle an event with a tcp handler" do
-    async_wrapper do
-      EM::start_server("127.0.0.1", 1234, Helpers::TestServer) do |server|
-        server.expected = @event_data
-      end
-      @server.handle_event(@handlers[:tcp], @event_data)
-    end
-  end
-
-  it "can handle an event with a udp handler" do
-    async_wrapper do
-      EM::open_datagram_socket("127.0.0.1", 1234, Helpers::TestServer) do |server|
-        server.expected = @event_data
-      end
-      @server.handle_event(@handlers[:udp], @event_data)
-    end
-  end
-
-  it "can handle an event with a transport handler" do
-    async_wrapper do
-      setup_transport do |transport|
-        transport.subscribe(:direct, "events") do |_, payload|
-          expect(Sensu::JSON.load(payload)).to eq(Sensu::JSON.load(@event_data))
-          async_done
-        end
-      end
-      timer(0.5) do
-        @server.setup_transport do
-          @server.handle_event(@handlers[:transport], @event_data)
-        end
-      end
-    end
-  end
-
-  it "can handle an event with an extension" do
-    async_wrapper do
-      @server.handle_event(@extensions[:handlers]["debug"], @event_data)
-      timer(0.5) do
-        async_done
-      end
-    end
-  end
-end
diff --git a/spec/server/mutate_spec.rb b/spec/server/mutate_spec.rb
deleted file mode 100644
index a616f67..0000000
--- a/spec/server/mutate_spec.rb
+++ /dev/null
@@ -1,45 +0,0 @@
-require File.join(File.dirname(__FILE__), "..", "helpers.rb")
-
-require "sensu/server/process"
-
-describe "Sensu::Server::Mutate" do
-  include Helpers
-
-  before do
-    @server = Sensu::Server::Process.new(options)
-    @event = event_template
-  end
-
-  it "can mutate event data" do
-    async_wrapper do
-      handler = {
-        :mutator => "unknown"
-      }
-      @server.mutate_event(handler, @event) do |event_data|
-        raise "should never get here"
-      end
-      handler[:mutator] = "explode"
-      @server.mutate_event(handler, @event) do |event_data|
-        raise "should never get here"
-      end
-      handler[:mutator] = "fail"
-      @server.mutate_event(handler, @event) do |event_data|
-        raise "should never get here"
-      end
-      handler.delete(:mutator)
-      @server.mutate_event(handler, @event) do |event_data|
-        expected = Sensu::JSON.dump(@event)
-        expect(Sensu::JSON.load(event_data)).to eq(Sensu::JSON.load(expected))
-        handler[:mutator] = "only_check_output"
-        @server.mutate_event(handler, @event) do |event_data|
-          expect(event_data).to eq("WARNING")
-          handler[:mutator] = "tag"
-          @server.mutate_event(handler, @event) do |event_data|
-            expect(Sensu::JSON.load(event_data)).to include(:mutated)
-            async_done
-          end
-        end
-      end
-    end
-  end
-end
diff --git a/spec/server/process_spec.rb b/spec/server/process_spec.rb
deleted file mode 100644
index 95273e3..0000000
--- a/spec/server/process_spec.rb
+++ /dev/null
@@ -1,837 +0,0 @@
-require File.join(File.dirname(__FILE__), "..", "helpers.rb")
-
-require "sensu/server/process"
-
-describe "Sensu::Server::Process" do
-  include Helpers
-
-  before do
-    @server = Sensu::Server::Process.new(options)
-    @event = event_template
-  end
-
-  it "can connect to redis" do
-    async_wrapper do
-      @server.setup_redis do |connection|
-        connection.callback do
-          expect(connection.connected?).to eq(true)
-          async_done
-        end
-      end
-    end
-  end
-
-  it "can connect to the transport" do
-    async_wrapper do
-      @server.setup_transport do
-        timer(0.5) do
-          async_done
-        end
-      end
-    end
-  end
-
-  it "can consume client keepalives" do
-    async_wrapper do
-      @server.setup_connections do
-        @server.setup_keepalives
-        keepalive = client_template
-        keepalive[:timestamp] = epoch
-        redis.flushdb do
-          timer(1) do
-            setup_transport do |transport|
-              transport.publish(:direct, "keepalives", Sensu::JSON.dump(keepalive))
-            end
-            timer(1) do
-              redis.sismember("clients", "i-424242") do |exists|
-                expect(exists).to be(true)
-                redis.get("client:i-424242") do |client_json|
-                  client = Sensu::JSON.load(client_json)
-                  expect(client).to eq(keepalive)
-                  read_event_file = Proc.new do
-                    begin
-                      event_file = IO.read("/tmp/sensu_client_registration.json")
-                      Sensu::JSON.load(event_file)
-                    rescue
-                      retry
-                    end
-                  end
-                  compare_event_file = Proc.new do |event_file|
-                    expect(event_file[:check][:name]).to eq("registration")
-                    expect(event_file[:client]).to eq(keepalive)
-                    async_done
-                  end
-                  EM.defer(read_event_file, compare_event_file)
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can consume client keepalives with client signatures" do
-    async_wrapper do
-      @server.setup_connections do
-        @server.setup_keepalives
-        keepalive = client_template
-        keepalive[:timestamp] = epoch
-        keepalive[:signature] = "foo"
-        redis.flushdb do
-          timer(1) do
-            setup_transport do |transport|
-              transport.publish(:direct, "keepalives", Sensu::JSON.dump(keepalive))
-              timer(1) do
-                redis.get("client:i-424242") do |client_json|
-                  client = Sensu::JSON.load(client_json)
-                  expect(client).to eq(keepalive)
-                  redis.get("client:i-424242:signature") do |signature|
-                    expect(signature).to eq("foo")
-                    malicious = keepalive.dup
-                    malicious[:timestamp] = epoch
-                    malicious[:signature] = "bar"
-                    transport.publish(:direct, "keepalives", Sensu::JSON.dump(malicious))
-                    timer(1) do
-                      redis.get("client:i-424242") do |client_json|
-                        client = Sensu::JSON.load(client_json)
-                        expect(client).to eq(keepalive)
-                        redis.get("client:i-424242:signature") do |signature|
-                          expect(signature).to eq("foo")
-                          async_done
-                        end
-                      end
-                    end
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can derive handlers from a handler list containing a nested set" do
-    handler_list = ["nested_set_one"]
-    handlers = @server.derive_handlers(handler_list)
-    expect(handlers.size).to eq(2)
-    expect(handlers.first).to be_an_instance_of(Sensu::Extension::Debug)
-    expected = {
-      :name => "file",
-      :type => "pipe",
-      :command => "cat > /tmp/sensu_event"
-    }
-    expect(handlers.last).to eq(expected)
-  end
-
-  it "can aggregate check results" do
-    async_wrapper do
-      @server.setup_redis do
-        clients = ["foo", "bar", "baz", "qux"]
-        redis.flushdb do
-          clients.each do |client_name|
-            client = client_template
-            client[:name] = client_name
-            check = check_template
-            check[:aggregate] = true
-            @server.aggregate_check_result(client, check)
-            check = check_template
-            check[:aggregate] = "foobar"
-            @server.aggregate_check_result(client, check)
-          end
-          timer(2) do
-            redis.sismember("aggregates", "test") do |exists|
-              expect(exists).to be(true)
-              redis.sismember("aggregates", "foobar") do |exists|
-                expect(exists).to be(true)
-                expected_members = clients.map do |client_name|
-                  "#{client_name}:test"
-                end
-                redis.smembers("aggregates:test") do |aggregate_members|
-                  expect(aggregate_members).to match_array(expected_members)
-                  redis.smembers("aggregates:foobar") do |aggregate_members|
-                    expect(aggregate_members).to match_array(expected_members)
-                    async_done
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can aggregate check results across multiple named aggregates" do
-    async_wrapper do
-      aggregates = ["foo", "bar"]
-      redis.flushdb do
-        client = client_template
-        client[:name] = "aggro"
-        check = check_template
-        check[:aggregates] = aggregates
-        @server.setup_redis do
-          @server.aggregate_check_result(client, check)
-          timer(2) do
-            redis.sismember("aggregates", "foo") do |exists|
-              expect(exists).to be(true)
-              redis.smembers("aggregates:foo") do |aggregate_members|
-                expect(aggregate_members).to include("aggro:test")
-                redis.sismember("aggregates", "bar") do |exists|
-                  expect(exists).to be(true)
-                  redis.smembers("aggregates:bar") do |aggregate_members|
-                    expect(aggregate_members).to include("aggro:test")
-                    async_done
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can process results with flap detection" do
-    async_wrapper do
-      @server.setup_redis do
-        redis.flushdb do
-          client = client_template
-          redis.set("client:i-424242", Sensu::JSON.dump(client)) do
-            26.times do |index|
-              result = result_template
-              result[:check][:low_flap_threshold] = 5
-              result[:check][:high_flap_threshold] = 20
-              result[:check][:status] = index % 2
-              @server.process_check_result(result)
-            end
-            timer(1) do
-              redis.llen("history:i-424242:test") do |length|
-                expect(length).to eq(21)
-                redis.hget("events:i-424242", "test") do |event_json|
-                  event = Sensu::JSON.load(event_json)
-                  expect(event[:action]).to eq("flapping")
-                  expect(event[:occurrences]).to be_within(2).of(1)
-                  26.times do |index|
-                    result = result_template
-                    result[:check][:low_flap_threshold] = 5
-                    result[:check][:high_flap_threshold] = 20
-                    result[:check][:status] = 0
-                    @server.process_check_result(result)
-                  end
-                  timer(1) do
-                    redis.hexists("events:i-424242", "test") do |exists|
-                      expect(exists).to be(false)
-                      async_done
-                    end
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can process results with silencing" do
-    async_wrapper do
-      @server.setup_redis do
-        redis.flushdb do
-          redis.set("client:i-424242", Sensu::JSON.dump(client_template)) do
-            silenced_info = {
-              :id => "test:*"
-            }
-            redis.set("silence:test:*", Sensu::JSON.dump(silenced_info)) do
-              silenced_info[:id] = "*:test"
-              redis.set("silence:*:test", Sensu::JSON.dump(silenced_info)) do
-                silenced_info[:id] = "test:test"
-                redis.set("silence:test:test", Sensu::JSON.dump(silenced_info)) do
-                  @server.process_check_result(result_template)
-                  timer(1) do
-                    redis.hget("events:i-424242", "test") do |event_json|
-                      event = Sensu::JSON.load(event_json)
-                      expect(event[:silenced]).to eq(true)
-                      expect(event[:silenced_by]).to eq(["test:*", "test:test", "*:test"])
-                      async_done
-                    end
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can expire silenced entries on event resolution" do
-    async_wrapper do
-      @server.setup_redis do
-        FileUtils.rm_rf("/tmp/sensu_event")
-        expect(File.exists?("/tmp/sensu_event")).to eq(false)
-        redis.flushdb do
-          redis.set("client:i-424242", Sensu::JSON.dump(client_template)) do
-            silenced_info = {
-              :id => "test:*",
-              :expire_on_resolve => true
-            }
-            redis.set("silence:test:*", Sensu::JSON.dump(silenced_info)) do
-              result = result_template
-              result[:check][:handler] = "file"
-              @server.process_check_result(result)
-              timer(1) do
-                expect(File.exists?("/tmp/sensu_event")).to eq(false)
-                result[:check][:status] = 0
-                @server.process_check_result(result)
-                timer(1) do
-                  expect(File.exists?("/tmp/sensu_event")).to eq(true)
-                  async_done
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can have event id and occurrence watermark persist until the event is resolved" do
-    async_wrapper do
-      @server.setup_redis do
-        redis.flushdb do
-          client = client_template
-          redis.set("client:i-424242", Sensu::JSON.dump(client)) do
-            @server.process_check_result(result_template)
-            @server.process_check_result(result_template)
-            timer(2) do
-              redis.hget("events:i-424242", "test") do |event_json|
-                event = Sensu::JSON.load(event_json)
-                event_id = event[:id]
-                expect(event[:occurrences]).to eq(2)
-                expect(event[:occurrences_watermark]).to eq(2)
-                result = result_template
-                result[:check][:status] = 2
-                @server.process_check_result(result)
-                timer(2) do
-                  redis.hget("events:i-424242", "test") do |event_json|
-                    event = Sensu::JSON.load(event_json)
-                    expect(event[:id]).to eq(event_id)
-                    expect(event[:occurrences]).to eq(1)
-                    expect(event[:occurrences_watermark]).to eq(2)
-                    async_done
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can not resolve events when provided the option" do
-    async_wrapper do
-      @server.setup_redis do
-        redis.flushdb do
-          client = client_template
-          redis.set("client:i-424242", Sensu::JSON.dump(client)) do
-            result = result_template
-            result[:check][:auto_resolve] = false
-            @server.process_check_result(result)
-            timer(1) do
-              redis.hget("events:i-424242", "test") do |event_json|
-                event = Sensu::JSON.load(event_json)
-                expect(event[:action]).to eq("create")
-                expect(event[:occurrences]).to eq(1)
-                result[:check][:status] = 0
-                @server.process_check_result(result)
-                timer(1) do
-                  redis.hget("events:i-424242", "test") do |event_json|
-                    event = Sensu::JSON.load(event_json)
-                    expect(event[:action]).to eq("create")
-                    expect(event[:occurrences]).to eq(1)
-                    expect(event[:check][:status]).to eq(1)
-                    async_done
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can consume results" do
-    async_wrapper(30) do
-      @server.setup_connections do
-        @server.setup_results
-        redis.flushdb do
-          timer(1) do
-            client = client_template
-            redis.set("client:i-424242", Sensu::JSON.dump(client)) do
-              result = result_template
-              setup_transport do |transport|
-                transport.publish(:direct, "results", Sensu::JSON.dump(result))
-                timer(1) do
-                  transport.publish(:direct, "results", Sensu::JSON.dump(result))
-                  timer(2) do
-                    redis.sismember("result:i-424242", "test") do |is_member|
-                      expect(is_member).to be(true)
-                      redis.get("result:i-424242:test") do |result_json|
-                        result = Sensu::JSON.load(result_json)
-                        expect(result[:output]).to eq("WARNING")
-                        timer(7) do
-                          redis.hget("events:i-424242", "test") do |event_json|
-                            event = Sensu::JSON.load(event_json)
-                            expect(event[:id]).to be_kind_of(String)
-                            expect(event[:check][:status]).to eq(1)
-                            expect(event[:occurrences]).to eq(2)
-                            expect(event[:occurrences_watermark]).to eq(2)
-                            expect(event[:last_ok]).to be_within(30).of(epoch)
-                            expect(event[:silenced]).to eq(false)
-                            expect(event[:silenced_by]).to be_empty
-                            expect(event[:action]).to eq("create")
-                            expect(event[:timestamp]).to be_within(10).of(epoch)
-                            read_event_file = Proc.new do
-                              begin
-                                event_file = IO.read("/tmp/sensu_event_bridge.json")
-                                Sensu::JSON.load(event_file)
-                              rescue
-                                retry
-                              end
-                            end
-                            compare_event_file = Proc.new do |event_file|
-                              expect(event_file[:check]).to eq(event[:check])
-                              expect(event_file[:client]).to eq(event[:client])
-                              async_done
-                            end
-                            EM.defer(read_event_file, compare_event_file)
-                          end
-                        end
-                      end
-                    end
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can consume results with signatures" do
-    async_wrapper(30) do
-      @server.setup_connections do
-        @server.setup_results
-        redis.flushdb do
-          timer(1) do
-            client = client_template
-            client[:signature] = "foo"
-            redis.set("client:i-424242", Sensu::JSON.dump(client)) do
-              result = result_template
-              setup_transport do |transport|
-                transport.publish(:direct, "results", Sensu::JSON.dump(result))
-                timer(1) do
-                  redis.sismember("result:i-424242", "test") do |is_member|
-                    expect(is_member).to be(false)
-                    result[:signature] = "foo"
-                    transport.publish(:direct, "results", Sensu::JSON.dump(result))
-                    timer(1) do
-                      redis.sismember("result:i-424242", "test") do |is_member|
-                        expect(is_member).to be(true)
-                        async_done
-                      end
-                    end
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can truncate check result output for storage" do
-    async_wrapper do
-      @server.setup_connections do
-        @server.setup_results
-        redis.flushdb do
-          timer(1) do
-            check = check_template
-            check[:output] = "foo"
-            truncated = @server.truncate_check_output(check)
-            expect(truncated[:output]).to eq("foo")
-            check[:output] = ""
-            truncated = @server.truncate_check_output(check)
-            expect(truncated[:output]).to eq("")
-            check[:output] = "foo\nbar\nbaz"
-            truncated = @server.truncate_check_output(check)
-            expect(truncated[:output]).to eq("foo\nbar\nbaz")
-            check[:type] = "metric"
-            truncated = @server.truncate_check_output(check)
-            expect(truncated[:output]).to eq("foo\n...")
-            check[:output] = "foo"
-            truncated = @server.truncate_check_output(check)
-            expect(truncated[:output]).to eq("foo")
-            check[:output] = "foo\255"
-            truncated = @server.truncate_check_output(check)
-            expect(truncated[:output]).to eq("foo")
-            check[:output] = ""
-            truncated = @server.truncate_check_output(check)
-            expect(truncated[:output]).to eq("")
-            check[:output] = rand(36**256).to_s(36).rjust(256, '0')
-            truncated = @server.truncate_check_output(check)
-            expect(truncated[:output]).to eq(check[:output][0..255] + "\n...")
-            client = client_template
-            redis.set("client:i-424242", Sensu::JSON.dump(client)) do
-              result = result_template
-              result[:check][:type] = "metric"
-              result[:check][:output] = "foo\nbar\nbaz"
-              setup_transport do |transport|
-                transport.publish(:direct, "results", Sensu::JSON.dump(result))
-              end
-              timer(2) do
-                redis.sismember("result:i-424242", "test") do |is_member|
-                  expect(is_member).to be(true)
-                  redis.get("result:i-424242:test") do |result_json|
-                    result = Sensu::JSON.load(result_json)
-                    expect(result[:output]).to eq("foo\n...")
-                    async_done
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can dynamically create a client for a check source" do
-    async_wrapper do
-      @server.setup_connections do
-        @server.setup_results
-        redis.flushdb do
-          timer(1) do
-            result = result_template
-            result[:check][:source] = "i-888888"
-            result[:check][:handler] = "debug"
-            setup_transport do |transport|
-              transport.publish(:direct, "results", Sensu::JSON.dump(result))
-            end
-            timer(3) do
-              redis.sismember("clients", "i-888888") do |exists|
-                expect(exists).to be(true)
-                redis.get("client:i-888888") do |client_json|
-                  client = Sensu::JSON.load(client_json)
-                  expect(client[:keepalives]).to be(false)
-                  expect(client[:version]).to eq(Sensu::VERSION)
-                  redis.hget("events:i-888888", "test") do |event_json|
-                    event = Sensu::JSON.load(event_json)
-                    expect(event[:client][:address]).to eq("unknown")
-                    expect(event[:client][:subscriptions]).to include("client:i-888888")
-                    async_done
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can publish check requests" do
-    async_wrapper do
-      setup_transport do |transport|
-        transport.subscribe(:fanout, "test") do |_, payload|
-          check_request = Sensu::JSON.load(payload)
-          expect(check_request[:name]).to eq("test")
-          expect(check_request[:command]).to eq("echo WARNING && exit 1")
-          expect(check_request[:source]).to eq("switch-x")
-          expect(check_request[:issued]).to be_within(10).of(epoch)
-          async_done
-        end
-      end
-      timer(0.5) do
-        @server.setup_transport do
-          check = check_template
-          check[:subscribers] = ["test"]
-          check[:source] = "switch-x"
-          @server.publish_check_request(check)
-        end
-      end
-    end
-  end
-
-  it "can publish check requests to round-robin subscriptions" do
-    async_wrapper do
-      setup_transport do |transport|
-        transport.subscribe(:direct, "roundrobin:test") do |_, payload|
-          check_request = Sensu::JSON.load(payload)
-          expect(check_request[:name]).to eq("test")
-          expect(check_request[:command]).to eq("echo WARNING && exit 1")
-          expect(check_request[:issued]).to be_within(10).of(epoch)
-          async_done
-        end
-      end
-      timer(0.5) do
-        @server.setup_transport do
-          check = check_template
-          check[:subscribers] = ["roundrobin:test"]
-          @server.publish_check_request(check)
-        end
-      end
-    end
-  end
-
-  it "can publish extension check requests" do
-    async_wrapper do
-      setup_transport do |transport|
-        transport.subscribe(:fanout, "test") do |_, payload|
-          check_request = Sensu::JSON.load(payload)
-          expect(check_request[:name]).to eq("test")
-          expect(check_request[:source]).to eq("switch-x")
-          expect(check_request[:extension]).to eq("rspec")
-          expect(check_request[:issued]).to be_within(10).of(epoch)
-          expect(check_request).not_to include(:command)
-          async_done
-        end
-      end
-      timer(0.5) do
-        @server.setup_transport do
-          check = check_template
-          check.delete(:command)
-          check[:extension] = "rspec"
-          check[:subscribers] = ["test"]
-          check[:source] = "switch-x"
-          @server.publish_check_request(check)
-        end
-      end
-    end
-  end
-
-  it "can calculate a check execution splay interval" do
-    allow(Time).to receive(:now).and_return("1414213569.032")
-    check = check_template
-    check[:interval] = 60
-    expect(@server.calculate_check_execution_splay(check)).to eq(17.601)
-    check[:interval] = 3600
-    expect(@server.calculate_check_execution_splay(check)).to eq(3497.601)
-  end
-
-  it "can schedule check request publishing" do
-    async_wrapper do
-      expected = ["tokens", "merger", "sensu_cpu_time", "source"]
-      setup_transport do |transport|
-        transport.subscribe(:fanout, "test") do |_, payload|
-          check_request = Sensu::JSON.load(payload)
-          expect(check_request[:issued]).to be_within(10).of(epoch)
-          expect(expected.delete(check_request[:name])).not_to be_nil
-          async_done if expected.empty?
-        end
-      end
-      timer(0.5) do
-        @server.setup_transport do
-          @server.setup_check_request_publisher
-        end
-      end
-    end
-  end
-
-  it "can send a check result" do
-    async_wrapper do
-      result_queue do |payload|
-        result = Sensu::JSON.load(payload)
-        expect(result[:client]).to eq("i-424242")
-        expect(result[:check][:name]).to eq("test")
-        async_done
-      end
-      timer(0.5) do
-        @server.setup_connections do
-          client = client_template
-          check = result_template[:check]
-          @server.publish_check_result(client[:name], check)
-        end
-      end
-    end
-  end
-
-  it "can determine stale clients and create the appropriate events" do
-    async_wrapper do
-      @server.setup_connections do
-        @server.setup_results
-        client1 = client_template
-        client1[:name] = "foo"
-        client1[:timestamp] = epoch - 60
-        client1[:keepalive][:handler] = "debug"
-        client2 = client_template
-        client2[:name] = "bar"
-        client2[:timestamp] = epoch - 120
-        client3 = client_template
-        client3[:name] = "qux"
-        client3[:keepalives] = false
-        client3[:timestamp] = epoch - 1800
-        redis.set("client:foo", Sensu::JSON.dump(client1)) do
-          redis.sadd("clients", "foo") do
-            redis.set("client:bar", Sensu::JSON.dump(client2)) do
-              redis.sadd("clients", "bar") do
-                redis.set("client:qux", Sensu::JSON.dump(client3)) do
-                  redis.sadd("clients", "qux") do
-                    @server.determine_stale_clients
-                    timer(1) do
-                      redis.hget("events:foo", "keepalive") do |event_json|
-                        event = Sensu::JSON.load(event_json)
-                        expect(event[:check][:status]).to eq(1)
-                        expect(event[:check][:handler]).to eq("debug")
-                        redis.hget("events:bar", "keepalive") do |event_json|
-                          event = Sensu::JSON.load(event_json)
-                          expect(event[:check][:status]).to eq(2)
-                          expect(event[:check][:handler]).to eq("keepalive")
-                          redis.hget("events:qux", "keepalive") do |event_json|
-                            expect(event_json).to be(nil)
-                            async_done
-                          end
-                        end
-                      end
-                    end
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can determine stale check results" do
-    async_wrapper do
-      @server.setup_connections do
-        @server.setup_results
-        redis.flushdb do
-          timer(1) do
-            client = client_template
-            redis.set("client:i-424242", Sensu::JSON.dump(client)) do
-              redis.sadd("clients", "i-424242") do
-                result = result_template
-                result[:check][:status] = 0
-                result[:check][:executed] = epoch - 30
-                setup_transport do |transport|
-                  transport.publish(:direct, "results", Sensu::JSON.dump(result))
-                  result[:check][:name] = "foo"
-                  result[:check][:ttl] = 30
-                  transport.publish(:direct, "results", Sensu::JSON.dump(result))
-                  result[:check][:name] = "bar"
-                  result[:check][:ttl] = 60
-                  transport.publish(:direct, "results", Sensu::JSON.dump(result))
-                  result[:check][:name] = "baz"
-                  result[:check][:ttl] = 30
-                  result[:check][:ttl_status] = 2
-                  transport.publish(:direct, "results", Sensu::JSON.dump(result))
-                  timer(2) do
-                    @server.determine_stale_check_results(45)
-                    timer(2) do
-                      redis.hgetall("events:i-424242") do |events|
-                        expect(events.size).to eq(2)
-                        event = Sensu::JSON.load(events["foo"])
-                        expect(event[:check][:output]).to match(/Last check execution was 3[0-9] seconds ago/)
-                        expect(event[:check][:status]).to eq(1)
-                        expect(event[:check][:interval]).to eq(45)
-                        event = Sensu::JSON.load(events["baz"])
-                        expect(event[:check][:output]).to match(/Last check execution was 3[0-9] seconds ago/)
-                        expect(event[:check][:status]).to eq(2)
-                        async_done
-                      end
-                    end
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can skip creating stale check results when client has a keepalive event" do
-    async_wrapper do
-      redis.flushdb do
-        @server.setup_connections do
-          @server.setup_results
-          client = client_template
-          client[:timestamp] = epoch - 120
-          redis.set("client:i-424242", Sensu::JSON.dump(client)) do
-            redis.sadd("clients", "i-424242") do
-              @server.determine_stale_clients
-              timer(1) do
-                redis.hget("events:i-424242", "keepalive") do |event_json|
-                  event = Sensu::JSON.load(event_json)
-                  expect(event[:check][:status]).to eq(2)
-                  stale_result = result_template
-                  stale_result[:check][:status] = 0
-                  stale_result[:check][:ttl] = 60
-                  stale_result[:check][:executed] = epoch - 1200
-                  setup_transport do |transport|
-                    transport.publish(:direct, "results", Sensu::JSON.dump(stale_result)) do
-                      @server.determine_stale_check_results
-                      timer(1) do
-                        redis.hexists("events:i-424242", "test") do |ttl_event_exists|
-                          expect(ttl_event_exists).to eq(false)
-                          async_done
-                        end
-                      end
-                    end
-                  end
-                end
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-
-  it "can be the leader and resign" do
-    async_wrapper do
-      @server.setup_connections do
-        redis.flushdb do
-          @server.request_leader_election
-          timer(1) do
-            expect(@server.is_leader).to be(true)
-            @server.resign_as_leader
-            expect(@server.is_leader).to be(false)
-            async_done
-          end
-        end
-      end
-    end
-  end
-
-  it "can be the only leader" do
-    async_wrapper do
-      server1 = @server.clone
-      server2 = @server.clone
-      server1.setup_connections do
-        server2.setup_connections do
-          redis.flushdb do
-            lock_timestamp = (Time.now.to_f * 1000).to_i - 60000
-            redis.set("lock:leader", lock_timestamp) do
-              server1.setup_leader_monitor
-              server2.setup_leader_monitor
-              timer(3) do
-                expect([server1.is_leader, server2.is_leader].uniq.size).to eq(2)
-                async_done
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-end
-- 
2.7.4

